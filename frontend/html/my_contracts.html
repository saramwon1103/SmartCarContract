<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>My Contracts | Morent</title>
    <link rel="stylesheet" href="../css/admin_dashboard.css" />
    <link rel="stylesheet" href="../css/my_contracts.css" />
    <link rel="stylesheet" href="../css/owner_confirmation.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    <style>
      .wallet-section {
        margin-bottom: 20px;
      }
      
      .wallet-card {
        background: #fff;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        border: 1px solid #e5e7eb;
      }
      
      .wallet-status {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      
      .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #ef4444;
        transition: background 0.3s;
      }
      
      .status-dot.connected {
        background: #10b981;
      }
      
      .btn-connect {
        background: #3b82f6;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.3s;
      }
      
      .btn-connect:hover {
        background: #2563eb;
      }
      
      .wallet-info {
        border-top: 1px solid #e5e7eb;
        padding-top: 15px;
      }
      
      .wallet-address {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        font-family: monospace;
        font-size: 14px;
      }
      
      .wallet-balances {
        display: flex;
        gap: 20px;
      }
      
      .balance-item {
        display: flex;
        justify-content: space-between;
        min-width: 100px;
        font-weight: 500;
      }
      
      .payment-section {
        margin-top: 20px;
        padding: 15px;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        background: #f9fafb;
      }
      
      .payment-info {
        margin-bottom: 15px;
      }
      
      .payment-amount {
        font-size: 18px;
        font-weight: bold;
        color: #059669;
        margin: 10px 0;
      }
      
      .btn-pay {
        background: #059669;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 16px;
        transition: background 0.3s;
        width: 100%;
      }
      
      .btn-pay:hover:not(:disabled) {
        background: #047857;
      }
      
      .btn-pay:disabled {
        background: #9ca3af;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <div class="dashboard-container">
      <!-- Sidebar will be loaded by appropriate sidebar component based on user role -->

      <main class="main">
        <header class="topbar">
          <div class="search">
            <input id="searchContracts" type="text" placeholder="Search contract id, car, customer..." />
            <span class="filter"><img src="../image/search.svg" alt="Search" class="icon"></span>
          </div>
          <div class="user-icons">
            <img src="https://i.pravatar.cc/40" alt="avatar" class="avatar" />
          </div>
        </header>

        <section class="content">
          <!-- Wallet Connection Section -->
          <div class="wallet-section">
            <div class="wallet-card">
              <div class="wallet-status">
                <div class="status-indicator">
                  <div id="wallet-status-dot" class="status-dot"></div>
                  <span id="wallet-status-text">Wallet not connected</span>
                </div>
                <button id="connect-wallet-btn" class="btn btn-connect">Connect Wallet</button>
                <button id="buy-cpt-btn" class="btn btn-connect" style="display: none; margin-left: 10px; background: #059669;">Buy CPT</button>
              </div>
              
              <div id="wallet-info" class="wallet-info" style="display: none;">
                <div class="wallet-address">
                  <span>Address:</span>
                  <span id="wallet-address">-</span>
                </div>
                <div class="wallet-balances">
                  <div class="balance-item">
                    <span>ETH:</span>
                    <span id="eth-balance">0.0000</span>
                  </div>
                  <div class="balance-item">
                    <span>CPT:</span>
                    <span id="cpt-balance">0.00</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="left-panel left-panel-full">
            <div class="card">
              <div class="header filter-header">
                <h3>My Contracts</h3>
                <div class="filter-controls">
                  <select id="statusFilter" class="status-filter">
                    <option value="">All Status</option>
                    <option value="Pending">Pending</option>
                    <option value="Active">Active</option>
                    <option value="Completed">Completed</option>
                    <option value="Terminated">Terminated</option>
                  </select>
                  <button id="refreshBtn" class="btn-primary">Refresh</button>
                </div>
              </div>

              <!-- Stats Cards -->
              <div class="stats-grid">
                <div class="stat-card">
                  <p>Total Contracts</p>
                  <h4 id="totalContracts">0</h4>
                </div>
                <div class="stat-card">
                  <p>Active</p>
                  <h4 id="activeContracts">0</h4>
                </div>
                <div class="stat-card">
                  <p>Pending</p>
                  <h4 id="pendingContracts">0</h4>
                </div>
                <div class="stat-card">
                  <p>Completed</p>
                  <h4 id="completedContracts">0</h4>
                </div>
              </div>

              <!-- Contracts Table -->
              <div class="table-container">
                <table id="contractsTable" class="contract-table">
                  <thead>
                    <tr>
                      <th>Contract ID</th>
                      <th>Car</th>
                      <th>Type</th>
                      <th>Period</th>
                      <th>Status</th>
                      <th>Total Price</th>
                      <th>Actions</th>
                    </tr>
                  </thead>
                  <tbody id="contractsTableBody">
                    <tr><td colspan="7" class="table-empty">Loading contracts...</td></tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          <!-- RIGHT PANEL - Contract Details -->
          <div class="right-panel">
            <div class="card rental-details" id="contractDetails">
              <h3>Contract Details</h3>
              <div class="car-box">
                <img id="detailCarImage" src="" alt="Car image">
                <div>
                  <h4 id="detailCarName">-</h4>
                  <p id="detailCarType">-</p>
                </div>
              </div>
              
              <div class="contract-details-info">
                <div class="contract-basic-info">
                  <h5>Basic Information</h5>
                  <p>Contract ID: <span id="detailContractId">-</span></p>
                  <p>Type: <span id="detailContractType">-</span></p>
                  <p>Transaction: <span id="detailTXHash">-</span></p>
                  <p>Start Date: <span id="detailStartDate">-</span></p>
                  <p>End Date: <span id="detailEndDate">-</span></p>
                </div>
                
                <div class="contract-counterparty-info">
                  <h5>Counterparty Information</h5>
                  <p>Name: <span id="detailCounterpartyName">-</span></p>
                  <p>Email: <span id="detailCounterpartyEmail">-</span></p>
                </div>
                
                <div class="contract-payment-info">
                  <h5>Payment Information</h5>
                  <p>Installment Amount: <span id="detailInstallmentAmount">-</span></p>
                  <p>Paid Periods: <span id="detailPaidPeriods">-</span> / <span id="detailTotalPeriods">-</span></p>
                  <p>Next Payment Due: <span id="detailNextPayment">-</span></p>
                </div>
                
                <div class="total-price">
                  <p>Total Price</p>
                  <h3 id="detailTotalPrice">-</h3>
                </div>
                
                <!-- Payment Section -->
                <div id="payment-section" class="payment-section" style="display: none;">
                  <h5>üí≥ Make Payment</h5>
                  <div class="payment-info">
                    <p>You need to complete payment to activate this contract.</p>
                    <div class="payment-amount">
                      Pay: <span id="payment-amount">0.00 CPT</span>
                    </div>
                  </div>
                  <button id="make-payment-btn" class="btn-pay" disabled>Connect Wallet to Pay</button>
                </div>
                
                <!-- Owner Confirmation Section -->
                <div id="owner-confirmation-section" class="payment-section" style="display: none; background: #fff3cd;">
                  <h5>üî∏ Owner Action Required</h5>
                  <div class="payment-info">
                    <p>As the car owner, you need to confirm this contract request.</p>
                  </div>
                  <div style="display: flex; gap: 10px;">
                    <button id="approve-contract-btn" class="btn-pay" style="background: #28a745;">Approve Contract</button>
                    <button id="reject-contract-btn" class="btn-pay" style="background: #dc3545;">Reject Contract</button>
                  </div>
                </div>
                
                <!-- Owner Payment Confirmation Section -->
                <div id="owner-payment-confirmation-section" class="payment-section" style="display: none; background: #d1ecf1;">
                  <h5>üí∞ Payment Received Confirmation</h5>
                  
                  <!-- Debug Panel -->
                  <div id="debug-panel" class="wallet-status" style="margin: 10px 0; padding: 10px; background: #f0f8ff; border: 1px solid #cce7ff; border-radius: 5px; font-family: monospace; font-size: 12px;">
                    <strong>üîß DEBUG INFO:</strong><br>
                    <span id="debug-current-user">User: Loading...</span><br>
                    <span id="debug-current-account">Account: Loading...</span><br>
                    <span id="debug-provider">Provider: Loading...</span><br>
                    <span id="debug-ethereum">Ethereum: Loading...</span><br>
                    <button id="debug-refresh-btn" style="margin-top: 5px; padding: 5px 10px; font-size: 10px;">üîÑ Refresh Status</button>
                  </div>
                  
                  <div class="payment-info">
                    <p>User has paid <span id="paid-amount">0.00 CPT</span>. Please check your wallet and confirm payment received.</p>
                    <div class="wallet-status" style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                      <strong>Wallet Status:</strong> <span id="wallet-status">Checking...</span><br>
                      <strong>Connected Address:</strong> <span id="wallet-address">-</span>
                    </div>
                  </div>
                  <button id="connect-wallet-owner-btn" class="btn-pay" style="background: #ffc107; color: #000; display: none; margin-right: 10px;">üîó Connect MetaMask</button>
                  <button id="confirm-payment-received-btn" class="btn-pay" style="background: #17a2b8;">‚úÖ Confirm Payment Received</button>
                </div>
                
                <div class="contract-actions">
                  <button id="payBtn" class="btn-primary">Pay Installment</button>
                  <button id="viewOnChain" class="btn-secondary">View on Blockchain</button>
                </div>
              </div>

              <!-- Empty State -->
              <div class="card" id="emptyState">
                <p>Select a contract to view details</p>
              </div>
            </div>
          </div>
        </section>
      </main>
    </div>

  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>
  <script src="../js/auth.js"></script>
  <script src="../js/contract-notifications.js"></script>
    
    <script>
      // Initialize page
      document.addEventListener('DOMContentLoaded', () => {
        console.log('My Contracts page loaded');
        
        // Load appropriate sidebar based on user role
        const user = AuthManager.getCurrentUser();
        
        if (user && user.Role === 'Owner') {
          console.log('Loading owner sidebar...');
          // Load owner sidebar component
          const script = document.createElement('script');
          script.src = '../js/owner_sidebar.js';
          script.onload = () => {
            console.log('Owner sidebar loaded successfully');
          };
          document.head.appendChild(script);
        } else if (user && user.Role === 'User') {
          console.log('Loading user sidebar...');
          // Load user sidebar component
          const script = document.createElement('script');
          script.src = '../js/user_sidebar.js';
          script.onload = () => {
            console.log('User sidebar loaded successfully');
          };
          document.head.appendChild(script);
        } else {
          console.log('No user or unknown role, loading default sidebar');
        }
        
        // Initialize contracts manager after sidebar is loaded
        setTimeout(() => {
          initializeContractsPage();
        }, 1000); // TƒÉng th·ªùi gian ƒë·ªÉ ƒë·∫£m b·∫£o sidebar load xong
      });
      
      function initializeContractsPage() {
        console.log('Initializing contracts page...');
        
        // Initialize wallet connection
        if (typeof window.ethereum !== 'undefined') {
          console.log('MetaMask detected, initializing wallet...');
          provider = new ethers.BrowserProvider(window.ethereum);
          
          // Check for existing connection
          checkExistingConnection();
        } else {
          console.log('MetaMask not detected');
        }
        
        // This function will be called after sidebar is loaded
        // Any additional initialization can be added here
      }
      
      // Clear wallet connection
      function clearWalletConnection() {
        currentAccount = null;
        provider = null;
        cptContract = null;
        ethBalance = 0;
        cptBalance = 0;
        updateWalletUI();
        updatePaymentSection();
        console.log('Wallet connection cleared');
      }
      
      // Buy CPT with ETH
      async function showBuyCptModal() {
        if (!currentAccount) {
          alert('Please connect your wallet first');
          return;
        }

        try {
          // Get exchange rate from API (which gets it from CarPayToken contract)
          const rateResponse = await fetch(`${API_BASE_URL}/wallet/exchange-rate`);
          const rateData = await rateResponse.json();
          
          if (!rateData.success) {
            throw new Error('Failed to get exchange rate from CarPayToken contract');
          }
          
          const cptForOneETH = rateData.cptForOneETH;
          const ethForOneCPT = rateData.ethForOneCPT;
          
          const ethAmount = prompt(`Enter ETH amount to spend (e.g., 0.1):\n\nCurrent rate from CarPayToken contract:\n1 ETH = ${cptForOneETH.toFixed(2)} CPT\n1 CPT = ${ethForOneCPT.toFixed(6)} ETH`);
          
          if (!ethAmount || isNaN(ethAmount) || parseFloat(ethAmount) <= 0) {
            return;
          }
          
          const expectedCptAmount = parseFloat(ethAmount) * cptForOneETH;
          
          const confirmed = confirm(`Purchase ${expectedCptAmount.toFixed(2)} CPT with ${ethAmount} ETH?\n\nUsing CarPayToken contract rate:\n1 ETH = ${cptForOneETH.toFixed(2)} CPT`);
          if (!confirmed) return;
          
          await buyCptWithEth(parseFloat(ethAmount), expectedCptAmount);
          
        } catch (error) {
          console.error('Error in buy CPT process:', error);
          alert('Failed to buy CPT: ' + error.message);
        }
      }

      async function buyCptWithEth(ethAmount, expectedCptAmount) {
        try {
          // Call CarPayToken contract's buyTokens function
          const signer = await provider.getSigner();
          const cptContractWithSigner = new ethers.Contract(
            CONTRACT_ADDRESSES.CPT_TOKEN, 
            [
              "function balanceOf(address owner) view returns (uint256)",
              "function transfer(address to, uint256 amount) returns (bool)",
              "function approve(address spender, uint256 amount) returns (bool)",
              "function tokenPrice() view returns (uint256)",
              "function buyTokens() payable"
            ], 
            signer
          );
          
          // Send ETH to buyTokens function
          const tx = await cptContractWithSigner.buyTokens({
            value: ethers.parseEther(ethAmount.toString()),
            gasLimit: 100000
          });
          
          console.log('Buy CPT transaction sent:', tx.hash);
          await tx.wait();
          
          // Call API to verify and record purchase
          const response = await fetch(`${API_BASE_URL}/wallet/buy-cpt`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              userWalletAddress: currentAccount,
              ethAmount,
              txHash: tx.hash
            })
          });
          
          const result = await response.json();
          
          if (result.success) {
            alert(`‚úÖ Successfully purchased ${result.transaction.cptAmount.toFixed(2)} CPT with ${ethAmount} ETH!`);
            await loadBalances();
          } else {
            throw new Error(result.error);
          }
          
        } catch (error) {
          console.error('CPT purchase error:', error);
          throw error;
        }
      }
    </script>
    <script src="../js/my_contracts.js"></script>
    
    <script>
      // Wallet Connection Logic
      let provider = null;
      let currentAccount = null;
      let cptContract = null;
      let ethBalance = 0;
      let cptBalance = 0;
      
      // Track processed payment transactions to prevent duplicates
      const processedPayments = new Set();
      
      // Function to sync current account across variables
      function setCurrentAccount(account) {
        currentAccount = account;
        window.currentAccount = account;
        console.log('Current account set to:', account);
      }
      
      function getCurrentAccount() {
        return currentAccount || window.currentAccount;
      }
      
      const API_BASE_URL = 'http://localhost:3000/api';
      const CPT_TOKEN_PRICE = 0.000287; // ETH per CPT token (from CarPayToken contract)
      
      const CONTRACT_ADDRESSES = {
        CPT_TOKEN: '0x5fbdb2315678afecb367f032d93f642f64180aa3', // Update with actual deployed address
        RENTAL_FACTORY: '0xe7f1725e7734ce288f8367e1bb143e90bb3f0512' // Update with actual deployed address
      };
      
      // Helper function to calculate ETH required for CPT amount from contract
      async function calculateETHAmountFromContract(cptAmount) {
        try {
          // Get exchange rate from backend API (which gets from CarPayToken contract)
          const rateResponse = await fetch(`${API_BASE_URL}/wallet/exchange-rate`);
          const rateData = await rateResponse.json();
          
          if (!rateData.success) {
            throw new Error('Failed to get exchange rate from CarPayToken contract');
          }
          
          const ethForOneCPT = rateData.ethForOneCPT;
          return cptAmount * ethForOneCPT;
        } catch (error) {
          console.error('Error getting exchange rate:', error);
          // Fallback to static price if API fails
          return cptAmount * CPT_TOKEN_PRICE;
        }
      }
      
      // Helper function to calculate ETH required for CPT amount (legacy)
      function calculateETHAmount(cptAmount) {
        return cptAmount * CPT_TOKEN_PRICE;
      }
      
      // Function to buy CPT tokens with ETH automatically during payment
      async function buyTokensWithETH(cptAmount) {
        try {
          if (!provider || !currentAccount) {
            throw new Error('Please connect your wallet first');
          }

          const signer = await provider.getSigner();
          const ethRequired = calculateETHAmount(cptAmount);
          
          console.log(`Buying ${cptAmount} CPT tokens for ${ethRequired} ETH`);

          // CPT Token contract ABI
          const cptTokenAbi = [
            "function buyTokens() public payable",
            "function balanceOf(address owner) view returns (uint256)",
            "function tokenPrice() view returns (uint256)"
          ];

          const cptTokenContract = new ethers.Contract(
            CONTRACT_ADDRESSES.CPT_TOKEN,
            cptTokenAbi,
            signer
          );

          // Convert ETH to Wei
          const ethInWei = ethers.parseEther(ethRequired.toString());

          console.log('Calling buyTokens with ETH amount:', ethInWei.toString());

          // Call buyTokens function with ETH payment
          const tx = await cptTokenContract.buyTokens({
            value: ethInWei
          });

          console.log('Buy tokens transaction submitted:', tx.hash);
          
          return {
            tx: tx,
            ethSpent: ethRequired,
            cptReceived: cptAmount
          };

        } catch (error) {
          console.error('Error buying tokens:', error);
          throw new Error(`Failed to buy CPT tokens: ${error.message}`);
        }
      }
      
      document.addEventListener('DOMContentLoaded', () => {
        console.log('My Contracts page loaded, initializing wallet...');
        // Initialize wallet after a small delay to ensure DOM is ready
        setTimeout(() => {
          initializeWallet();
        }, 500);
      });
      
      function initializeWallet() {
        console.log('Initializing wallet connection...');
        const connectBtn = document.getElementById('connect-wallet-btn');
        const buyCptBtn = document.getElementById('buy-cpt-btn');
        
        if (!connectBtn) {
          console.error('Connect wallet button not found!');
          return;
        }
        
        if (typeof window.ethereum === 'undefined') {
          console.log('MetaMask not detected');
          connectBtn.textContent = 'Install MetaMask';
          connectBtn.onclick = () => window.open('https://metamask.io/', '_blank');
          return;
        }
        
        console.log('MetaMask detected, setting up provider...');
        provider = new ethers.BrowserProvider(window.ethereum);
        
        connectBtn.addEventListener('click', connectWallet);
        
        if (buyCptBtn) {
          buyCptBtn.addEventListener('click', showBuyCptModal);
        }
        
        // Setup payment button handler immediately
        setupPaymentButtonHandler();
        
        // Check if already connected
        checkExistingConnection();
      }
      
      async function checkExistingConnection() {
        try {
          // Ki·ªÉm tra user hi·ªán t·∫°i c√≥ wallet hay ch∆∞a
          const currentUser = AuthManager.getCurrentUser();
          if (!currentUser) {
            console.log('No user logged in, skipping wallet check');
            return;
          }

          const accounts = await window.ethereum.request({ method: 'eth_accounts' });
          if (accounts.length > 0) {
            const connectedWallet = accounts[0].toLowerCase();
            
            // For Owners, allow auto-connect with any wallet
            if (currentUser.Role === 'Owner') {
              currentAccount = accounts[0];
              await setupWalletConnection();
              console.log('Auto-connected owner wallet:', currentAccount);
              return;
            }
            
            // For Users, check if wallet matches database
            try {
              const response = await fetch(`http://localhost:3000/api/users/${currentUser.UserId}/wallet`);
              const walletData = await response.json();
              
              if (walletData.success && walletData.wallet && walletData.wallet.WalletAddress) {
                const userWallet = walletData.wallet.WalletAddress.toLowerCase();
                
                // Ch·ªâ auto-connect n·∫øu wallet kh·ªõp
                if (connectedWallet === userWallet) {
                  currentAccount = accounts[0];
                  await setupWalletConnection();
                  console.log('Auto-connected to user wallet:', currentAccount);
                } else {
                  console.log('MetaMask wallet does not match user wallet');
                  // Clear connection n·∫øu kh√¥ng kh·ªõp
                  currentAccount = null;
                  updateWalletUI();
                }
              } else {
                console.log('User has no wallet registered');
              }
            } catch (error) {
              console.error('Error checking user wallet:', error);
            }
          }
        } catch (error) {
          console.error('Error checking existing connection:', error);
        }
      }
      
      async function connectWallet() {
        try {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          setCurrentAccount(accounts[0]);
          
          const currentUser = AuthManager.getCurrentUser();
          
          // For Users, save wallet to database
          // For Owners, just connect without saving (they can use any wallet for confirmation)
          if (currentUser && currentUser.Role === 'User') {
            await saveWalletToDatabase(currentAccount);
          }
          
          await setupWalletConnection();
          
          console.log('Wallet connected:', currentAccount);
          console.log('User role:', currentUser?.Role);
        } catch (error) {
          console.error('Error connecting wallet:', error);
          alert('Failed to connect wallet: ' + error.message);
        }
      }
      
      async function saveWalletToDatabase(walletAddress) {
        try {
          const currentUser = AuthManager.getCurrentUser();
          if (!currentUser) {
            throw new Error('No user logged in');
          }

          const response = await fetch(`http://localhost:3000/api/users/${currentUser.UserId}/wallet`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              walletAddress: walletAddress,
              network: 'Hardhat'
            })
          });

          const result = await response.json();
          if (!result.success) {
            throw new Error(result.error || 'Failed to save wallet');
          }
          
          console.log('Wallet saved to database successfully');
        } catch (error) {
          console.error('Error saving wallet to database:', error);
          // Don't throw error, just log it - wallet still works locally
        }
      }
      
      async function setupWalletConnection() {
        try {
          const signer = await provider.getSigner();
          
          // Setup CPT contract
          const cptAbi = [
            "function balanceOf(address owner) view returns (uint256)",
            "function transfer(address to, uint256 amount) returns (bool)",
            "function approve(address spender, uint256 amount) returns (bool)"
          ];
          
          cptContract = new ethers.Contract(CONTRACT_ADDRESSES.CPT_TOKEN, cptAbi, signer);
          
          updateWalletUI();
          await loadBalances();
          
          // Setup payment button handler if not already done
          setupPaymentButtonHandler();
          
          // Update payment section after wallet connection
          setTimeout(() => {
            updatePaymentSection();
          }, 200);
        } catch (error) {
          console.error('Error setting up wallet connection:', error);
        }
      }
      
      function updateWalletUI() {
        console.log('Updating wallet UI, current account:', currentAccount);
        const statusDot = document.getElementById('wallet-status-dot');
        const statusText = document.getElementById('wallet-status-text');
        const walletInfo = document.getElementById('wallet-info');
        const connectBtn = document.getElementById('connect-wallet-btn');
        const buyCptBtn = document.getElementById('buy-cpt-btn');
        const addressEl = document.getElementById('wallet-address');
        
        console.log('UI Elements found:', {
          statusDot: !!statusDot,
          statusText: !!statusText, 
          walletInfo: !!walletInfo,
          connectBtn: !!connectBtn,
          buyCptBtn: !!buyCptBtn,
          addressEl: !!addressEl
        });
        
        if (currentAccount) {
          console.log('Setting connected state...');
          statusDot.classList.add('connected');
          statusText.textContent = 'Wallet Connected';
          walletInfo.style.display = 'block';
          connectBtn.style.display = 'none';
          buyCptBtn.style.display = 'inline-block';
          addressEl.textContent = currentAccount.substring(0, 6) + '...' + currentAccount.substring(38);
        } else {
          console.log('Setting disconnected state...');
          statusDot.classList.remove('connected');
          statusText.textContent = 'Wallet not connected';
          walletInfo.style.display = 'none';
          connectBtn.style.display = 'inline-block';
          buyCptBtn.style.display = 'none';
        }
      }
      
      async function loadBalances() {
        try {
          // Get ETH balance
          const ethBalanceWei = await provider.getBalance(currentAccount);
          ethBalance = parseFloat(ethers.formatEther(ethBalanceWei));
          document.getElementById('eth-balance').textContent = ethBalance.toFixed(4);
          
          // Try to get CPT balance from backend API first
          try {
            const response = await fetch(`${API_BASE_URL}/wallet/cpt-balance/${currentAccount}`);
            const data = await response.json();
            
            if (data.success) {
              cptBalance = parseFloat(data.balance);
              document.getElementById('cpt-balance').textContent = cptBalance.toFixed(2);
              console.log('CPT balance from API:', cptBalance);
            } else {
              throw new Error(data.error || 'API failed');
            }
          } catch (apiError) {
            console.warn('Failed to load CPT balance from API:', apiError);
            // Fallback: set a default balance for testing
            cptBalance = 100.00; // Default test balance
            document.getElementById('cpt-balance').textContent = cptBalance.toFixed(2);
            console.log('Using default CPT balance:', cptBalance);
          }
          
          updatePaymentSection();
        } catch (error) {
          console.error('Error loading balances:', error);
          // Set default values on error
          ethBalance = 0;
          cptBalance = 100; // Default for testing
          document.getElementById('eth-balance').textContent = '0.0000';
          document.getElementById('cpt-balance').textContent = '100.00';
        }
      }
      
      function updatePaymentSection() {
        const makePaymentBtn = document.getElementById('make-payment-btn');
        const paymentSection = document.getElementById('payment-section');
        
        if (!makePaymentBtn || !paymentSection) return;
        
        const contract = window.contractsManager?.selectedContract;
        const currentUser = window.AuthManager?.getCurrentUser();
        const account = getCurrentAccount();
        
        if (!contract || !currentUser) return;
        
        // Hide payment section initially
        paymentSection.style.display = 'none';
        
        // Only show for User role and Active contracts
        if (currentUser.Role === 'User' && contract.Status === 'Active') {
          paymentSection.style.display = 'block';
          
          const paymentAmount = parseFloat(contract.TotalPrice || 0);
          const ethRequired = paymentAmount * CPT_TOKEN_PRICE;
          
          document.getElementById('payment-amount').textContent = `${paymentAmount.toFixed(2)} CPT (${ethRequired.toFixed(6)} ETH)`;
          
          if (account && ethBalance >= ethRequired) {
            makePaymentBtn.disabled = false;
            makePaymentBtn.textContent = `Pay ${ethRequired.toFixed(6)} ETH`;
            makePaymentBtn.style.background = '#059669';
          } else if (account) {
            makePaymentBtn.disabled = true;
            makePaymentBtn.textContent = `Insufficient ETH (Need ${ethRequired.toFixed(6)} ETH)`;
            makePaymentBtn.style.background = '#ef4444';
          } else {
            makePaymentBtn.disabled = true;
            makePaymentBtn.textContent = 'Connect Wallet to Pay';
            makePaymentBtn.style.background = '#9ca3af';
          }
        }
      }
      
      // Setup payment button handler once
      function setupPaymentButtonHandler() {
        const makePaymentBtn = document.getElementById('make-payment-btn');
        if (makePaymentBtn && !makePaymentBtn.dataset.handlerSet) {
          makePaymentBtn.dataset.handlerSet = 'true';
          makePaymentBtn.addEventListener('click', makeContractPayment);
          console.log('Payment button handler set up');
        }
      }
      
      async function makeContractPayment() {
        console.log('=== PAYMENT BUTTON CLICKED ===');
        
        try {
          // Get contract and account
          const contract = window.contractsManager?.selectedContract;
          const account = getCurrentAccount();
          
          console.log('Contract:', contract?.ContractId);
          console.log('Account:', account);
          console.log('Provider:', !!provider);
          
          if (!contract) {
            alert('Please select a contract first');
            return;
          }
          
          if (!account) {
            alert('Please connect your wallet first');
            return;
          }
          
          if (!provider) {
            alert('Provider not available');
            return;
          }
          
          const makePaymentBtn = document.getElementById('make-payment-btn');
          if (makePaymentBtn.disabled) {
            console.log('Button already disabled');
            return;
          }
          
          // Disable button immediately
          makePaymentBtn.disabled = true;
          makePaymentBtn.textContent = 'Processing...';
          
          const paymentAmount = parseFloat(contract.TotalPrice);
          const ethRequired = paymentAmount * CPT_TOKEN_PRICE;
          
          console.log('Payment amount:', paymentAmount, 'CPT');
          console.log('ETH required:', ethRequired);
          
          const confirmed = confirm(`Pay ${ethRequired.toFixed(6)} ETH for contract ${contract.ContractId}?`);
          
          if (!confirmed) {
            makePaymentBtn.disabled = false;
            makePaymentBtn.textContent = 'Pay Now';
            return;
          }
          
          // Send ETH to owner
          console.log('Sending ETH to owner:', contract.OwnerAddress);
          const signer = await provider.getSigner();
          const tx = await signer.sendTransaction({
            to: contract.OwnerAddress,
            value: ethers.parseEther(ethRequired.toString()),
            gasLimit: 21000
          });
          
          console.log('Payment sent:', tx.hash);
          makePaymentBtn.textContent = 'Confirming...';
          
          await tx.wait();
          console.log('Transaction confirmed');
          
          // Update backend
          const response = await fetch(`${API_BASE_URL}/contracts/${contract.ContractId}/payment`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              userWalletAddress: account,
              paymentTxHash: tx.hash,
              paymentAmount: paymentAmount,
              ethSpent: ethRequired,
              updateStatus: 'Paid'
            })
          });
          
          const result = await response.json();
          
          if (result.success) {
            alert(`‚úÖ Payment successful!\nTransaction: ${tx.hash}`);
            if (window.contractsManager?.loadContracts) {
              window.contractsManager.loadContracts();
            }
          } else {
            alert('Backend update failed: ' + (result.error || 'Unknown error'));
          }
          
        } catch (error) {
          console.error('Payment error:', error);
          alert('Payment failed: ' + error.message);
        } finally {
          // Re-enable button
          const makePaymentBtn = document.getElementById('make-payment-btn');
          if (makePaymentBtn) {
            makePaymentBtn.disabled = false;
            makePaymentBtn.textContent = 'Pay Now';
          }
        }
      }
      
      
      // Update debug panel
      function updateDebugPanel() {
        const debugCurrentUser = document.getElementById('debug-current-user');
        const debugCurrentAccount = document.getElementById('debug-current-account');
        const debugProvider = document.getElementById('debug-provider');
        const debugEthereum = document.getElementById('debug-ethereum');
        
        if (debugCurrentUser) {
          const user = window.AuthManager?.getCurrentUser();
          debugCurrentUser.textContent = `User: ${user ? `${user.FullName} (${user.Role})` : 'NULL'}`;
        }
        
        if (debugCurrentAccount) {
          debugCurrentAccount.textContent = `Account: ${currentAccount || 'NULL'}`;
        }
        
        if (debugProvider) {
          debugProvider.textContent = `Provider: ${provider ? 'CONNECTED' : 'NULL'}`;
        }
        
        if (debugEthereum) {
          debugEthereum.textContent = `Ethereum: ${window.ethereum ? 'AVAILABLE' : 'NOT_FOUND'}`;
        }
      }

      // Update owner wallet status
      async function updateOwnerWalletStatus() {
        console.log('=== UPDATE OWNER WALLET STATUS ===');
        console.log('Current account:', currentAccount);
        
        const walletStatus = document.getElementById('wallet-status');
        const walletAddress = document.getElementById('wallet-address');
        const connectBtn = document.getElementById('connect-wallet-owner-btn');
        const confirmBtn = document.getElementById('confirm-payment-received-btn');
        
        if (!walletStatus || !walletAddress || !connectBtn || !confirmBtn) {
          console.log('Wallet status elements not found yet');
          return;
        }
        
        // Try to get current account from MetaMask if not set
        if (!currentAccount && window.ethereum) {
          try {
            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
            if (accounts.length > 0) {
              currentAccount = accounts[0];
              console.log('Updated currentAccount from MetaMask:', currentAccount);
            }
          } catch (error) {
            console.error('Error getting MetaMask accounts:', error);
          }
        }
        
        // Update debug panel
        updateDebugPanel();
        
        if (currentAccount) {
          walletStatus.textContent = '‚úÖ Connected';
          walletStatus.style.color = '#28a745';
          walletAddress.textContent = currentAccount;
          connectBtn.style.display = 'none';
          confirmBtn.disabled = false;
          confirmBtn.style.opacity = '1';
          console.log('Wallet status updated: Connected');
        } else {
          walletStatus.textContent = '‚ùå Not Connected';
          walletStatus.style.color = '#dc3545';
          walletAddress.textContent = '-';
          connectBtn.style.display = 'inline-block';
          confirmBtn.disabled = true;
          confirmBtn.style.opacity = '0.5';
          console.log('Wallet status updated: Not Connected');
        }
      }
      
      // Setup owner confirmation handlers
      function setupOwnerConfirmationHandlers(contract) {
        const approveBtn = document.getElementById('approve-contract-btn');
        const rejectBtn = document.getElementById('reject-contract-btn');
        
        if (approveBtn && !approveBtn.dataset.handlerSet) {
          approveBtn.dataset.handlerSet = 'true';
          approveBtn.addEventListener('click', () => handleOwnerApproval(contract, 'approve'));
        }
        
        if (rejectBtn && !rejectBtn.dataset.handlerSet) {
          rejectBtn.dataset.handlerSet = 'true';
          rejectBtn.addEventListener('click', () => handleOwnerApproval(contract, 'reject'));
        }
      }
      
      // Setup owner payment confirmation handlers
      function setupOwnerPaymentConfirmationHandlers(contract) {
        const confirmBtn = document.getElementById('confirm-payment-received-btn');
        const connectBtn = document.getElementById('connect-wallet-owner-btn');
        const debugRefreshBtn = document.getElementById('debug-refresh-btn');
        
        // Setup debug refresh button
        if (debugRefreshBtn && !debugRefreshBtn.dataset.handlerSet) {
          debugRefreshBtn.dataset.handlerSet = 'true';
          debugRefreshBtn.addEventListener('click', async () => {
            console.log('=== REFRESHING DEBUG STATUS ===');
            
            // Try to get fresh account info from MetaMask
            if (window.ethereum) {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                console.log('Fresh MetaMask accounts:', accounts);
                
                if (accounts.length > 0) {
                  currentAccount = accounts[0];
                  console.log('Updated currentAccount:', currentAccount);
                  
                  if (!provider) {
                    provider = new ethers.BrowserProvider(window.ethereum);
                    console.log('Created new provider');
                  }
                }
              } catch (error) {
                console.error('Error getting fresh accounts:', error);
              }
            }
            
            updateDebugPanel();
            await updateOwnerWalletStatus();
          });
        }
        
        // Update debug panel initially
        updateDebugPanel();
        
        if (confirmBtn && !confirmBtn.dataset.handlerSet) {
          confirmBtn.dataset.handlerSet = 'true';
          confirmBtn.addEventListener('click', () => handleOwnerPaymentConfirmation(contract));
        }
        
        if (connectBtn && !connectBtn.dataset.handlerSet) {
          connectBtn.dataset.handlerSet = 'true';
          connectBtn.addEventListener('click', async () => {
            console.log('=== FORCE CONNECT WALLET ===');
            try {
              if (!window.ethereum) {
                throw new Error('MetaMask not found. Please install MetaMask extension.');
              }
              
              console.log('Requesting account access...');
              const accounts = await window.ethereum.request({ 
                method: 'eth_requestAccounts' 
              });
              
              console.log('Accounts received:', accounts);
              
              if (accounts.length === 0) {
                throw new Error('No accounts returned from MetaMask');
              }
              
              // Force set account and provider
              currentAccount = accounts[0];
              provider = new ethers.BrowserProvider(window.ethereum);
              
              console.log('‚úÖ Wallet connected successfully!');
              console.log('Account:', currentAccount);
              console.log('Provider:', !!provider);
              
              // Update all UI elements
              updateDebugPanel();
              await updateOwnerWalletStatus();
              
              alert(`üéâ Wallet connected successfully!\n\nüìç Address: ${currentAccount.substring(0, 6)}...${currentAccount.substring(38)}\n\nYou can now confirm payment receipt.`);
              
            } catch (error) {
              console.error('‚ùå Failed to connect wallet:', error);
              
              if (error.code === 4001) {
                alert('‚ùå Connection rejected by user.\n\nPlease approve the connection request in MetaMask.');
              } else if (error.code === -32002) {
                alert('‚è≥ Connection request pending.\n\nPlease check your MetaMask extension.');
              } else {
                alert('‚ùå Failed to connect wallet!\n\nError: ' + error.message + '\n\nPlease try again or refresh the page.');
              }
            }
          });
        }
      }
      
      // Handle owner approval/rejection
      async function handleOwnerApproval(contract, action) {
        try {
          const confirmed = confirm(`${action === 'approve' ? 'Approve' : 'Reject'} contract ${contract.ContractId}?`);
          if (!confirmed) return;
          
          const btn = document.getElementById(`${action}-contract-btn`);
          btn.disabled = true;
          btn.textContent = action === 'approve' ? 'Approving...' : 'Rejecting...';
          
          const response = await fetch(`${API_BASE_URL}/contracts/${contract.ContractId}/owner-action`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: action,
              ownerId: window.AuthManager.getCurrentUser().UserId
            })
          });
          
          const result = await response.json();
          
          if (result.success) {
            alert(`‚úÖ Contract ${action}d successfully!`);
            window.contractsManager?.loadContracts();
            updatePaymentSection();
          } else {
            throw new Error(result.error || `Failed to ${action} contract`);
          }
          
        } catch (error) {
          console.error(`Owner ${action} error:`, error);
          alert(`Failed to ${action} contract: ` + error.message);
        } finally {
          const btn = document.getElementById(`${action}-contract-btn`);
          if (btn) {
            btn.disabled = false;
            btn.textContent = action === 'approve' ? 'Approve Contract' : 'Reject Contract';
          }
        }
      }
      
      // Ensure wallet is connected for owner
      async function ensureOwnerWalletConnected() {
        console.log('=== ENSURING OWNER WALLET CONNECTED ===');
        
        if (!window.ethereum) {
          throw new Error('MetaMask not found. Please install MetaMask extension.');
        }
        
        try {
          // Get current accounts
          const accounts = await window.ethereum.request({ method: 'eth_accounts' });
          console.log('Available accounts:', accounts);
          
          if (accounts.length === 0) {
            // No accounts connected, request permission
            console.log('No accounts connected, requesting permission...');
            const requestedAccounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            console.log('Requested accounts:', requestedAccounts);
            
            if (requestedAccounts.length === 0) {
              throw new Error('No accounts granted permission');
            }
            
            setCurrentAccount(requestedAccounts[0]);
          } else {
            // Use existing connected account
            currentAccount = accounts[0];
          }
          
          // Ensure provider is set
          if (!provider) {
            provider = new ethers.BrowserProvider(window.ethereum);
          }
          
          console.log('‚úÖ Wallet connection ensured:', currentAccount);
          updateDebugPanel();
          await updateOwnerWalletStatus();
          
          return currentAccount;
          
        } catch (error) {
          console.error('‚ùå Error ensuring wallet connection:', error);
          throw error;
        }
      }

      // Handle owner payment confirmation
      async function handleOwnerPaymentConfirmation(contract) {
        try {
          console.log('=== OWNER PAYMENT CONFIRMATION DEBUG ===');
          console.log('Starting owner payment confirmation for contract:', contract.ContractId);
          console.log('Current user:', window.AuthManager?.getCurrentUser());
          console.log('Current account before ensure:', currentAccount);
          console.log('Provider:', !!provider);
          console.log('Window ethereum:', !!window.ethereum);
          
          // Ensure wallet is properly connected
          try {
            await ensureOwnerWalletConnected();
            console.log('Wallet connection ensured, currentAccount:', currentAccount);
          } catch (walletError) {
            console.error('Failed to ensure wallet connection:', walletError);
            alert('‚ùå Failed to connect wallet!\n\n' + walletError.message + '\n\nPlease make sure MetaMask is installed and unlocked.');
            return;
          }
          
          // Final check - ensure we have wallet and contract is valid
          if (!currentAccount) {
            alert('‚ùå Wallet connection failed. Please try connecting manually using the "Connect MetaMask" button.');
            return;
          }

          if (contract.Status !== 'Paid') {
            alert(`‚ùå Contract status is ${contract.Status}. Only Paid contracts can be confirmed.`);
            return;
          }

          const confirmed = confirm(`üí∞ CONFIRM PAYMENT RECEIVED\n\n‚úÖ Contract: ${contract.ContractId}\nüíµ Amount: ${contract.TotalPrice} CPT\nüîó Your wallet: ${currentAccount}\n\n‚ö†Ô∏è This will create a blockchain transaction to confirm payment receipt.\n\nProceed with confirmation?`);
          if (!confirmed) return;
          
          const btn = document.getElementById('confirm-payment-received-btn');
          btn.disabled = true;
          btn.textContent = 'Processing on Blockchain...';
          
          try {
            console.log('Creating blockchain transaction for owner confirmation...');
            // Create a blockchain transaction for owner confirmation
            const signer = await provider.getSigner();
            
            // Create a simple transaction to record the confirmation on blockchain
            const confirmationTx = await signer.sendTransaction({
              to: currentAccount, // Send to self as a record
              value: ethers.parseEther('0'), // No ETH transfer
              data: ethers.toUtf8Bytes(`CONFIRM_PAYMENT:${contract.ContractId}:${Date.now()}`), // Data payload
              gasLimit: 30000
            });

            console.log('Owner confirmation transaction submitted:', confirmationTx.hash);
            
            // Show transaction pending
            btn.textContent = 'Confirming on Blockchain...';
            
            // Wait for transaction confirmation
            console.log('Waiting for transaction confirmation...');
            const receipt = await confirmationTx.wait();
            console.log('Confirmation transaction receipt:', receipt);

            // Call backend to update contract status
            console.log('=== CALLING BACKEND ===');
            console.log('Final currentAccount:', currentAccount);
            console.log('Final confirmationTx.hash:', confirmationTx.hash);
            
            // Final validation before sending to backend
            if (!currentAccount) {
              throw new Error('Wallet address is missing. Please refresh and try again.');
            }
            
            if (!confirmationTx.hash) {
              throw new Error('Transaction hash is missing. Please try again.');
            }
            
            const requestBody = {
              ownerId: window.AuthManager.getCurrentUser().UserId,
              ownerWalletAddress: currentAccount,
              confirmationTxHash: confirmationTx.hash,
              gasUsed: receipt.gasUsed.toString(),
              blockNumber: receipt.blockNumber
            };
            
            console.log('Request body:', requestBody);
            
            const response = await fetch(`${API_BASE_URL}/contracts/${contract.ContractId}/confirm-payment-received`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(requestBody)
            });

            const result = await response.json();

            if (result.success) {
              alert(`‚úÖ Payment confirmation completed successfully!

üîó Confirmation Transaction: ${confirmationTx.hash}
‚õΩ Gas Used: ${receipt.gasUsed.toString()}
üì¶ Block Number: ${receipt.blockNumber}

Contract is now completed and recorded on blockchain.`);
              
              window.contractsManager?.loadContracts();
              updatePaymentSection();
            } else {
              throw new Error(result.error || 'Failed to update contract status');
            }

          } catch (blockchainError) {
            console.error('Blockchain transaction failed:', blockchainError);
            
            if (blockchainError.code === 4001) {
              // User rejected transaction
              alert('‚ùå Transaction was cancelled by user.\n\nPayment confirmation requires a blockchain transaction to complete.');
            } else if (blockchainError.code === -32602) {
              alert('‚ùå Invalid transaction parameters.\n\nPlease try again or contact support.');
            } else if (blockchainError.code === -32603) {
              alert('‚ùå Internal blockchain error.\n\nPlease check your wallet and try again.');
            } else {
              alert('‚ùå Blockchain transaction failed!\n\nError: ' + blockchainError.message + '\n\nPlease ensure you have enough ETH for gas fees and try again.');
            }
            throw blockchainError;
          }
          
        } catch (error) {
          console.error('Payment confirmation error:', error);
          alert('‚ùå Failed to confirm payment!\n\nError: ' + error.message + '\n\nPlease try again or contact support if the issue persists.');
        } finally {
          const btn = document.getElementById('confirm-payment-received-btn');
          if (btn) {
            btn.disabled = false;
            btn.textContent = 'Confirm Payment Received';
          }
        }
      }
      
      // Listen for account changes
      if (window.ethereum) {
        window.ethereum.on('accountsChanged', async (accounts) => {
          if (accounts.length > 0) {
            const newAccount = accounts[0].toLowerCase();
            const currentUser = AuthManager.getCurrentUser();
            
            if (currentUser) {
              try {
                // Check if user is Owner
                if (currentUser.Role === 'Owner') {
                  // For owners, allow any wallet connection for payment confirmation
                  currentAccount = accounts[0];
                  console.log('Owner account connected:', currentAccount);
                  updateWalletUI();
                  updatePaymentSection();
                  updateOwnerWalletStatus();
                  await loadBalances();
                  return;
                }
                
                // For Users, check if wallet matches database
                const response = await fetch(`http://localhost:3000/api/users/${currentUser.UserId}/wallet`);
                const walletData = await response.json();
                
                if (walletData.success && walletData.wallet && walletData.wallet.WalletAddress) {
                  const userWallet = walletData.wallet.WalletAddress.toLowerCase();
                  
                  if (newAccount === userWallet) {
                    currentAccount = accounts[0];
                    await setupWalletConnection();
                    console.log('User account changed to registered wallet:', currentAccount);
                    updateOwnerWalletStatus(); // Update owner wallet status
                  } else {
                    console.log('Account changed to non-registered wallet, disconnecting');
                    currentAccount = null;
                    updateWalletUI();
                    updatePaymentSection();
                    updateOwnerWalletStatus(); // Update owner wallet status
                  }
                } else {
                  // User ch∆∞a c√≥ wallet, disconnect
                  currentAccount = null;
                  updateWalletUI();
                  updatePaymentSection();
                  updateOwnerWalletStatus(); // Update owner wallet status
                }
              } catch (error) {
                console.error('Error checking account change:', error);
                currentAccount = null;
                updateWalletUI();
                updatePaymentSection();
                updateOwnerWalletStatus(); // Update owner wallet status
              }
            }
          } else {
            currentAccount = null;
            updateWalletUI();
            updatePaymentSection();
            updateOwnerWalletStatus(); // Update owner wallet status
          }
        });
      }
      
      // Debug function to check button status
      function debugPaymentButton() {
        const makePaymentBtn = document.getElementById('make-payment-btn');
        console.log('=== PAYMENT BUTTON DEBUG ===');
        console.log('Button exists:', !!makePaymentBtn);
        console.log('Button disabled:', makePaymentBtn?.disabled);
        console.log('Button text:', makePaymentBtn?.textContent);
        console.log('Handler set:', makePaymentBtn?.dataset?.handlerSet);
        console.log('Current account:', getCurrentAccount());
        console.log('Selected contract:', window.contractsManager?.selectedContract?.ContractId);
        console.log('ETH balance:', ethBalance);
        console.log('Provider:', !!provider);
      }
      
      // Make functions globally accessible
      window.makeContractPayment = makeContractPayment;
      window.connectWallet = connectWallet;
      window.updatePaymentSection = updatePaymentSection;
      window.debugPaymentButton = debugPaymentButton;
    </script>
  </body>
</html>